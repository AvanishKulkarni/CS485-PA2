

    
    
    (* BLOCK 1 BEGIN *)
    (* Check for duplicate attributes, methods with each class *)
    (* Check for duplicates in formal list *)
    List.iter (fun cname ->
        let attr_list = Hashtbl.find_all class_map_attr cname in 
        let attr_seen = ref SeenSet.empty in 

        (* Check if attribute redefined *)
        List.iter (fun ((loc,name),_, _) -> 
        if SeenSet.mem name !attr_seen then begin
            (* printf "ERROR: %s: Type-Check: class %s redefines attribute %s\n" loc cname name ;
            exit 1 *)
        end;
        attr_seen := SeenSet.add name !attr_seen;
        ) (List.rev attr_list);
        let meth_list = Hashtbl.find_all class_map_method cname in 
        let meth_seen = ref SeenSet.empty in 

        (* Check for redfined method *)
        List.iter (fun ((loc,mname),formal_list,_,_) -> if SeenSet.mem mname !meth_seen then begin 
                (* printf "ERROR: %s: Type-Check: class %s redefines method %s\n" loc cname mname ;
                exit 1; *)
            end else
                (* Check for duplicates in formal list *)
                let formal_seen = ref SeenSet.empty in 
                List.iter (fun ((loc, pname), _) -> 
                    if SeenSet.mem pname !formal_seen then begin 
                        (* printf "ERROR: %s: Type-Check: class %s has method %s with duplicate formal parameter named %s\n" loc cname mname pname;
                        exit 1; *)
                    end;
                    formal_seen := SeenSet.add pname !formal_seen;
                ) formal_list;
            meth_seen := SeenSet.add mname !meth_seen;
        ) (List.rev meth_list);
    ) all_classes;
    (* Checking to see if the main method has zero parameters *)
    List.iter (fun ((_,name),formals,_,_)->
        if (name = "main") && (List.length formals) <> 0 then begin
            (* printf "ERROR: 0: Type-Check: class Main method main with 0 parameters not found\n";
            exit 1;  *)
        end;
    ) (Hashtbl.find_all class_map_method "Main");
    (* BLOCK 1 END *)


    (* 
    Figure out if something is a subtype of another
    Find x on inheritance tree, traverse down the tree 
    until you find y => return true, else return false 
    *)

    (* Is x a subtype of y *)
    let is_subtype x y = 
        match x, y with 
        | x, y when x = y -> true (* same type *)
        | x, "Object" -> true (* subtype object *)
        | x, y -> let rec dfs_helper vert = (* checking inheritance map *)
            if vert = x then true
            else
                let children = Hashtbl.find_all inheritance vert in
                List.exists dfs_helper children
            in 
            dfs_helper y
    in

    (* BLOCK 2 *)
    (* Type Checking features *)
    let rec feature_check iname cname = 
        let inherited_methods = Hashtbl.find_all class_map_method iname in
        let inherited_attributes = Hashtbl.find_all class_map_attr iname in
        let inherited_attributes_names = List.map (fun ((_, name), _, _) -> name) inherited_attributes in
        let methods = Hashtbl.find_all class_map_method cname in
        let attributes = Hashtbl.find_all class_map_attr cname in
        (* Type checking attributes *)
        List.iter (fun ((aloc, name), (tloc, tname), _)->
            (* Checks for attributes called self *)
            if (name = "self") then begin
                (* printf "ERROR: %s: Type-Check: class %s has an attribute named self\n" aloc cname;
                exit 1; *)
            end;
            if (List.mem name inherited_attributes_names) then begin
                (* printf "ERROR: %s: Type-Check: class %s redefines attribute %s\n" aloc cname name;
                exit 1; *)
            end;
            if not ((List.mem tname all_classes)) && (tname <> "SELF_TYPE") then begin
                (* printf "ERROR: %s: Type-Check: class %s has attribute %s with unknown type %s\n" tloc cname name tname;
                exit 1; *)
            end;
        ) attributes;
        List.iter (fun ((mloc, mname), formal_list, (typeloc, mtype),_) ->
            (* Checks each formal parameter to see if the type exists *)
            List.iter (fun ((_, fname), (ftloc, ftype))->
                if not ((List.mem ftype all_classes)) then begin
                    (* printf "ERROR: %s: Type-Check: class %s has method %s with formal parameter of unknown type %s\n" ftloc cname mname ftype;
                    exit 1; *)
                end;
            ) formal_list;
            (* Checks the return type to see if the type exists *)
            if not (List.mem mtype all_classes) && (mtype <> "SELF_TYPE")then begin
                (* printf "ERROR: %s: Type-Check: class %s has method %s with unknown return type %s\n" typeloc cname mname mtype;
                exit 1; *)
            end;
            List.iter (fun ((imloc, imname), iformal_list, (itypeloc, imtype),_) ->
                (* if (mname = imname) then begin *)
                if (is_subtype mname imname) then begin
                    (* Checking for inherited method redefinitions*)
                    if (List.length formal_list <> List.length iformal_list) then begin
                        (* printf "ERROR: %s: Type-Check: class %s redefines method %s and changes number of formals\n" mloc cname mname;
                        exit 1; *)
                    end;
                    if (not (is_subtype mtype imtype)) then begin
                        (* printf "ERROR: %s: Type-Check: class %s redefines method %s and changes return type (from %s to %s)\n" typeloc cname mname imtype mtype;
                        exit 1; *)
                    end;
                    (* Checking if the formal types were changed *)
                    List.iter2 (fun ((fploc,fname), (ftloc, ftype)) ((_,ifname), (_, iftype)) ->
                        if (not (is_subtype ftype iftype)) then begin
                            (* printf "ERROR: %s: Type-Check: class %s redefines method %s and changes type of formal %s\n" ftloc cname mname fname;
                            exit 1; *)
                        end;
                    ) formal_list iformal_list;
                end;
            ) inherited_methods;
        ) methods;
        (* If no errors are found, then add inherited features to the class map*)
        List.iter (fun meth ->
            Hashtbl.add class_map_method cname meth;
        ) inherited_methods;
        List.iter (fun attr ->
            Hashtbl.add class_map_attr cname attr;
        ) inherited_attributes;
        let child_classes = Hashtbl.find_all inheritance cname in
        List.iter (fun cl ->
            feature_check cname cl;
        ) child_classes;
    in
    List.iter (fun cl -> 
        feature_check "Object" cl;
    ) (Hashtbl.find_all inheritance "Object");
    (* BLOCK 2 *)


    